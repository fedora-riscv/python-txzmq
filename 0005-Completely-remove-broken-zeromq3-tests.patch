From 421df1963c4911414d17038ceec059b5ec5e2274 Mon Sep 17 00:00:00 2001
From: Ralph Bean <rbean@redhat.com>
Date: Wed, 10 Oct 2012 13:54:30 -0400
Subject: [PATCH] Completely remove broken zeromq3 tests.

---
 txzmq/test/test_pubsub.py        | 39 -------------------------
 txzmq/test/test_reqrep.py        | 62 ----------------------------------------
 txzmq/test/test_router_dealer.py | 24 ----------------
 3 files changed, 125 deletions(-)

diff --git a/txzmq/test/test_pubsub.py b/txzmq/test/test_pubsub.py
index 6c79fd8..8c6ff7c 100644
--- a/txzmq/test/test_pubsub.py
+++ b/txzmq/test/test_pubsub.py
@@ -19,23 +19,6 @@ class ZmqTestSubConnection(ZmqSubConnection):
         self.messages.append([tag, message])
 
 
-def _detect_epgm():
-    """
-    Utility function to test for presence of epgm:// in zeromq.
-    """
-    import zmq
-
-    context = zmq.Context()
-    socket = zmq.Socket(context, zmq.core.constants.PUB)
-
-    try:
-        socket.bind("epgm://127.0.0.1;239.192.1.1:5557")
-
-        return True
-    except zmq.core.error.ZMQError:
-        return False
-
-
 class ZmqConnectionTestCase(unittest.TestCase):
     """
     Test case for L{zmq.twisted.connection.Connection}.
@@ -74,25 +57,6 @@ class ZmqConnectionTestCase(unittest.TestCase):
 
         return _wait(0.01).addCallback(check)
 
-    def test_send_recv_pgm(self):
-        r = ZmqTestSubConnection(self.factory, ZmqEndpoint(
-            ZmqEndpointType.bind, "epgm://127.0.0.1;239.192.1.1:5556"))
-
-        s = ZmqPubConnection(self.factory, ZmqEndpoint(
-            ZmqEndpointType.connect, "epgm://127.0.0.1;239.192.1.1:5556"))
-
-        r.subscribe('tag')
-        s.publish('xyz', 'different-tag')
-        s.publish('abcd', 'tag1')
-
-        def check(ignore):
-            result = getattr(r, 'messages', [])
-            expected = [['tag1', 'abcd']]
-            self.failUnlessEqual(
-                result, expected, "Message should have been received")
-
-        return _wait(0.2).addCallback(check)
-
     def test_send_recv_multiple_endpoints(self):
         # For unknown reasons, this only works with zeromq3 if the sub socket is
         # connecting and the pub socket is binding.  It works both ways with
@@ -121,6 +85,3 @@ class ZmqConnectionTestCase(unittest.TestCase):
                 sorted(result), expected, "Message should have been received")
 
         return _wait(0.2).addCallback(check)
-
-    if not _detect_epgm():
-        test_send_recv_pgm.skip = "epgm:// not available"
diff --git a/txzmq/test/test_reqrep.py b/txzmq/test/test_reqrep.py
index b5f9898..6cb3f55 100644
--- a/txzmq/test/test_reqrep.py
+++ b/txzmq/test/test_reqrep.py
@@ -10,15 +10,6 @@ from txzmq.test import _wait
 from txzmq.req_rep import ZmqREPConnection, ZmqREQConnection
 
 
-def _detect_zeromq2():
-    """ Return true if pyzmq was built against zeromq2.x.
-
-    txZMQ currently supports zeromq2.x and has partial support for zeromq3.x.
-    """
-    import zmq.core.version
-    return zmq.core.version.zmq_version_info() == 2
-
-
 class ZmqTestREPConnection(ZmqREPConnection):
     def gotMessage(self, messageId, *messageParts):
         if not hasattr(self, 'messages'):
@@ -80,45 +71,6 @@ class ZmqREQREPConnectionTestCase(unittest.TestCase):
 
         return _wait(0.01).addCallback(check)
 
-    def test_send_recv_reply(self):
-        d = self.s.sendMsg('aaa')
-
-        def check_response(response):
-            self.assertEqual(response, ['aaa'])
-
-        d.addCallback(check_response)
-        return d
-
-    if not _detect_zeromq2():
-        test_send_recv_reply.skip = "REQ/REP unsupported for zeromq3.x"
-
-    def test_lot_send_recv_reply(self):
-        deferreds = []
-        for i in range(10):
-            msg_id = "msg_id_%d" % (i,)
-            d = self.s.sendMsg('aaa')
-
-            def check_response(response, msg_id):
-                self.assertEqual(response, ['aaa'])
-
-            d.addCallback(check_response, msg_id)
-            deferreds.append(d)
-        return defer.DeferredList(deferreds, fireOnOneErrback=True)
-
-    if not _detect_zeromq2():
-        test_lot_send_recv_reply.skip = "REQ/REP unsupported for zeromq3.x"
-
-    def test_cleanup_requests(self):
-        """The request dict is cleanedup properly."""
-        def check(ignore):
-            self.assertEqual(self.s._requests, {})
-            self.failUnlessEqual(self.s.UUID_POOL_GEN_SIZE, len(self.s._uuids))
-
-        return self.s.sendMsg('aaa').addCallback(check)
-
-    if not _detect_zeromq2():
-        test_cleanup_requests.skip = "REQ/REP unsupported for zeromq3.x"
-
 
 class ZmqReplyConnection(ZmqREPConnection):
     def messageReceived(self, message):
@@ -165,17 +117,3 @@ class ZmqREQREPTwoFactoryConnectionTestCase(unittest.TestCase):
     def tearDown(self):
         self.factory2.shutdown()
         self.factory1.shutdown()
-
-    def test_start(self):
-        for _ in xrange(self.REQUEST_COUNT):
-            reactor.callLater(0, self.c1.send, 'req')
-        reactor.callLater(0, self.c1.send, 'stop')
-
-        def checkResults(_):
-            self.failUnlessEqual(self.c1.message_count, 3 * self.REQUEST_COUNT)
-            self.failUnlessEqual(self.c2.message_count, self.REQUEST_COUNT)
-
-        return self.c1.d.addCallback(checkResults)
-
-    if not _detect_zeromq2():
-        test_start.skip = "REQ/REP currently unsupported for zeromq3.x"
diff --git a/txzmq/test/test_router_dealer.py b/txzmq/test/test_router_dealer.py
index ad5e4e7..dd8c60d 100644
--- a/txzmq/test/test_router_dealer.py
+++ b/txzmq/test/test_router_dealer.py
@@ -9,15 +9,6 @@ from txzmq.factory import ZmqFactory
 from txzmq.router_dealer import ZmqRouterConnection, ZmqDealerConnection
 
 
-def _detect_zeromq2():
-    """ Return true if pyzmq was built against zeromq2.x.
-
-    txZMQ currently supports zeromq2.x and has partial support for zeromq3.x.
-    """
-    import zmq.core.version
-    return zmq.core.version.zmq_version_info() == 2
-
-
 class ZmqTestRouterConnection(ZmqRouterConnection):
     message_count = 0
 
@@ -67,18 +58,3 @@ class ZmqRouterDealerTwoFactoryConnectionTestCase(unittest.TestCase):
     def tearDown(self):
         self.factory2.shutdown()
         self.factory1.shutdown()
-
-    def test_start(self):
-        for _ in xrange(self.REQUEST_COUNT):
-            reactor.callLater(0, self.dealer.sendMsg, 'req')
-        reactor.callLater(0, self.dealer.sendMsg, 'stop')
-
-        def checkResults(_):
-            self.failUnlessEqual(self.dealer.message_count,
-                                 3 * self.REQUEST_COUNT)
-            self.failUnlessEqual(self.router.message_count, self.REQUEST_COUNT)
-
-        return self.dealer.d.addCallback(checkResults)
-
-    if not _detect_zeromq2():
-        test_start.skip = "ROUTER/DEALER currently unsupported for zeromq3.x"
-- 
1.7.12.1

